# -----------------------------------------------
# Kafka Seeder

# Script to seed kafka with data from the database
# and mock data from other services.
# -----------------------------------------------
# To seed from the database, pass the --pm flag
# To seed from the der warehouse, pass the --der_warehouse flag
# To seed from the der gateway, pass the --der_gateway flag
# Example (from src directory):
#     python -m pm.src.kafka --pm --der_warehouse --der_gateway
# -----------------------------------------------

import argparse
import json
from dataclasses import dataclass
from enum import Enum
from random import choice, randint
from time import sleep
from typing import Generator, Optional
from uuid import uuid4

import pendulum
from dotenv import load_dotenv

from pm.config import PMConfig
from pm.consumers.der_gateway.handlers import DER_CONTROL_TOPIC, DER_RESPONSE_TOPIC
from pm.consumers.der_warehouse.handlers import DER_WAREHOUSE_DER_TOPIC
from pm.modules.derinfo.enums import DerAssetType, DerResourceCategory, LimitUnitType

# models
from pm.modules.enrollment.models.enrollment import Contract, EnrollmentRequest
from pm.modules.event_tracking.models import *  # noqa
from pm.modules.progmgmt.models import *  # noqa
from pm.modules.serviceprovider.models import *  # noqa
from pm.topics import ContractMessage, EnrollmentMessage
from shared.system import configuration, database, loggingsys
from shared.tasks.producer import MessageData, Producer
from shared.utils import convert_datetimes_and_enums_to_string

# load env variables
load_dotenv()
configuration.init_config(PMConfig)
config = PMConfig.from_env()

# setup logging
loggingsys.init(config=config)

# init SQL Alchemy
database.init(config=config)

logger = loggingsys.get_logger(name=__name__)
logger.info("Starting kafka seeder...")


@dataclass
class KafkaSeeder:
    data: dict
    topic: str
    headers: Optional[dict] = None

    def send_to_kafka(self):
        value = json.dumps(self.data)
        Producer.send_json(topic=self.topic, json_str=value, headers=self.headers or {})


def _add_to_kafka(Model: type[database.Base], MessageType: type[MessageData]):
    """Add a message to kafka from a database entity"""
    with database.Session() as s:
        entities = s.query(Model).all()
        for entity in entities:
            msg = KafkaSeeder(
                topic=MessageType.TOPIC,
                data=convert_datetimes_and_enums_to_string(entity.to_dict()),
                headers=MessageType.headers,
            )  # type: ignore
            logger.info(f"Adding {msg.__class__.__name__} to kafka")
            msg.send_to_kafka()


def _generate_timestamps(weeks: int = 1) -> Generator[tuple[int, int], None, None]:
    """For every hour starting from a week ago, generate a start and end timestamp
    in unix time
    """
    now = pendulum.now()
    week_ago = now.subtract(weeks=weeks)
    while week_ago < now:
        start = week_ago.set(hour=week_ago.hour)
        end = start.add(hours=1)
        week_ago = week_ago.add(hours=1)
        yield start.int_timestamp, end.int_timestamp


def _generate_der_response_payloads(weeks_ago: int = 1) -> Generator[dict, None, None]:
    """
    Generate der response payloads using the timestamps generated by _generate_timestamps
    """
    for start, _ in _generate_timestamps(weeks_ago):
        yield {
            "controlId": f"{uuid4()}",
            "edevId": "9101080002",
            "status": randint(0, 11),
            "time": start,
        }


def _generate_der_control_payload(weeks_ago: int = 1) -> Generator[dict, None, None]:
    for start, end in _generate_timestamps(weeks_ago):
        yield {
            "dermControlId": "1",
            "dermDispatchId": "1",
            "controlId": f"{uuid4()}",
            "controlGroupId": "1",
            "initiallyParticipatingDERs": ["9101080001", "9101080002"],
            "creationTime": start,
            "dermUserId": "John Doe",
            "startTime": start,
            "endTime": end,
            "controlType": "kW % Rated Capacity",
            "controlSetpoint": "77.77",
            "controlEventStatus": "scheduled",
        }


def _generate_der_gateway_relay_payload(num_to_generate: int = 5) -> Generator[dict, None, None]:
    for _ in range(num_to_generate):
        id_value = randint(10000, 11000)
        yield {
            "program": {
                "id": id_value,
                "name": "Test Program",
                "program_type": "DEMAND_MANAGEMENT",
                "start_date": "2021-01-01T00:00:00+00:00",
                "end_date": "2021-12-31T00:00:00+00:00",
                "program_priority": 1,
                "control_type": "EXPORT_AND_IMPORT_LIMIT",
                "control_options": ["OP_MOD_CONNECT"],
                "holiday_exclusions": {
                    "calendars": [
                        {
                            "mrid": "mrid",
                            "timezone": "America/Los_Angeles",
                            "year": 2021,
                            "events": [
                                {
                                    "startDate": "2021-01-01T00:00:00",
                                    "endDate": "2021-01-01T00:00:00",
                                    "name": "New Year's Day",
                                    "category": "National Holiday",
                                    "substitutionDate": "2021-01-01T00:00:00",
                                }
                            ],
                        }
                    ]
                },
                "dispatch_constraints": {
                    "event_duration_constraint": {
                        "min": 1,
                        "max": 60,
                    },
                    "cumulative_event_duration": {
                        "DAY": {
                            "min": 1,
                            "max": 60,
                        },
                        "WEEK": {
                            "min": 1,
                            "max": 60,
                        },
                        "MONTH": {
                            "min": 1,
                            "max": 60,
                        },
                        "YEAR": {
                            "min": 1,
                            "max": 60,
                        },
                        "PROGRAM_DURATION": {
                            "min": 1,
                            "max": 60,
                        },
                    },
                    "max_number_of_events_per_timeperiod": {
                        "DAY": 1,
                        "WEEK": 1,
                        "MONTH": 1,
                        "YEAR": 1,
                        "PROGRAM_DURATION": 1,
                    },
                },
                "avail_service_windows": [
                    {
                        "id": 1,
                        "start_hour": 0,
                        "end_hour": 23,
                        "mon": True,
                        "tue": True,
                        "wed": True,
                        "thu": True,
                        "fri": True,
                        "sat": True,
                        "sun": True,
                    }
                ],
                "avail_operating_months": {
                    "id": 1,
                    "jan": True,
                    "feb": True,
                    "mar": True,
                    "apr": True,
                    "may": True,
                    "jun": True,
                    "jul": True,
                    "aug": True,
                    "sep": True,
                    "oct": True,
                    "nov": True,
                    "dec": True,
                },
                "demand_management_constraints": {
                    "max_total_energy_per_timeperiod": 1,
                    "max_total_energy_unit": "kWh",
                    "timeperiod": "DAY",
                },
            },
            "contract": {
                "id": id_value,
                "contract_type": "demand_response",
            },
            "enrollment": {
                "der_id": f"der_id--{id_value}",
            },
        }


def _get_random_enum_name(e: type[Enum]) -> str:
    """Get a random enum name from an enum"""
    return choice(list(e.__members__.keys()))


def _generate_der_payload(ders_count: int) -> Generator[dict, None, None]:
    for i in range(ders_count):
        yield {
            "id": i,
            "der_id": f"DERID-{i}",
            "name": f"MYDER-{i}",
            "der_type": _get_random_enum_name(DerAssetType),
            "resource_category": _get_random_enum_name(DerResourceCategory),
            "nameplate_rating": 50,
            "nameplate_rating_unit": _get_random_enum_name(LimitUnitType),
            "is_deleted": False,
            "extra": {},
            "created_at": str(pendulum.now()),
            "updated_at": str(pendulum.now()),
        }


def seed_kafka(pm: bool, der_warehouse: bool, der_gateway: bool, der_gateway_relay: bool):
    """Seed kafka with data from the database and mock data from other services"""
    # seed from database entities
    if pm:
        _add_to_kafka(EnrollmentRequest, EnrollmentMessage)
        _add_to_kafka(Contract, ContractMessage)
    # mock external topics
    seeds: list[KafkaSeeder] = []
    # DER Warehouse topics
    if der_warehouse:
        seeds += [
            KafkaSeeder(data=payload, topic=DER_WAREHOUSE_DER_TOPIC)
            for payload in _generate_der_payload(100)
        ]
    # DER Gateway topics
    if der_gateway:
        seeds += [
            KafkaSeeder(data=payload, topic=DER_CONTROL_TOPIC)
            for payload in _generate_der_control_payload()
        ]
        seeds += [
            KafkaSeeder(data=payload, topic=DER_RESPONSE_TOPIC)
            for payload in _generate_der_response_payloads()
        ]
    # der gateway relay topics
    logger.info("Relay...")
    if der_gateway_relay:
        logger.info("Relay...")
        seeds += [
            KafkaSeeder(data=payload, topic="der-gateway-program", headers={"operation": "create"})
            for payload in _generate_der_gateway_relay_payload()
        ]
    for s in seeds:
        s.send_to_kafka()
    Producer.flush()
    # sleep for 2 seconds to allow kafka to process the messages
    sleep(2)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Seed Kafka topics from different services."
        + "Services are: PM, DER Warehouse and DER Gateway."
        + "The PM topics will be seeded using data from the existing database."
        + "The DER Warehouse and DER Gateway topics will be seeded with mock data."
    )
    parser.add_argument(
        "--pm",
        help="Seed topics made from DB entities",
        action="store_true",
        required=False,
    )
    parser.add_argument(
        "--der_warehouse",
        help="Seed topics from DER Warehouse",
        action="store_true",
        required=False,
    )
    parser.add_argument(
        "--der_gateway",
        help="Seed topics from DER Gateway",
        action="store_true",
        required=False,
    )
    parser.add_argument(
        "--der_gateway_relay",
        help="Seed topics for DER Gateway Relay",
        action="store_true",
        required=False,
    )
    args = parser.parse_args()
    seed_kafka(args.pm, args.der_warehouse, args.der_gateway, args.der_gateway_relay)
